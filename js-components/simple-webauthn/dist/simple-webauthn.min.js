var SimpleWebAuthn=function(){"use strict";class e{static detectPlatform(){const e=navigator.userAgent,t=e.includes("Samsung")||e.includes("SM-");let r=6e4;t&&(r=3e5);let i="preferred";return t&&(i="required"),{isSamsung:t,isIOS:/iPad|iPhone|iPod/.test(e),isWindows:e.includes("Windows"),timeout:r,residentKey:i}}static logPlatformInfo(){const e=this.detectPlatform();console.log("=== Platform Detection ==="),console.log("User Agent:",navigator.userAgent),console.log("Platform:",navigator.platform),console.log("Samsung:",e.isSamsung),console.log("iOS:",e.isIOS),console.log("Windows:",e.isWindows),console.log("Timeout:",e.timeout,"ms"),console.log("Resident Key:",e.residentKey),console.log("========================")}}class t{static async encryptData(e,t,r){try{const r=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:(new TextEncoder).encode("clypse-encryption-salt-v1"),info:(new TextEncoder).encode("clypse-encryption-key")},t,{name:"AES-GCM",length:256},!1,["encrypt"]),i=crypto.getRandomValues(new Uint8Array(12)),a=(new TextEncoder).encode(e),n=await crypto.subtle.encrypt({name:"AES-GCM",iv:i},r,a),o=new Uint8Array(i.length+n.byteLength);o.set(i,0),o.set(new Uint8Array(n),i.length);return{success:!0,encryptedData:btoa(String.fromCharCode(...o))}}catch(e){return{success:!1,error:`Encryption failed: ${e instanceof Error?e.message:"Unknown error"}`}}}static async decryptData(e,t,r){try{const r=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:(new TextEncoder).encode("clypse-encryption-salt-v1"),info:(new TextEncoder).encode("clypse-encryption-key")},t,{name:"AES-GCM",length:256},!1,["decrypt"]),i=Uint8Array.from(atob(e),e=>e.charCodeAt(0)),a=i.slice(0,12),n=i.slice(12),o=await crypto.subtle.decrypt({name:"AES-GCM",iv:a},r,n);return{success:!0,plaintext:(new TextDecoder).decode(o)}}catch(e){return{success:!1,error:`Decryption failed: ${e instanceof Error?e.message:"Unknown error"}`}}}static async importKeyMaterial(e){return await crypto.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"])}}class r{static async createCredential(e,r){try{if(!e.encryptionSalt||""===e.encryptionSalt.trim())return{success:!1,error:"encryptionSalt is required and cannot be empty"};const i=crypto.getRandomValues(new Uint8Array(32)),a=crypto.getRandomValues(new Uint8Array(32)),n={challenge:i,rp:{name:e.rp.name,id:e.rp.id||window.location.hostname},user:{id:a,name:e.user.name,displayName:e.user.displayName},pubKeyCredParams:e.pubKeyCredParams,timeout:e.timeout||r.timeout,authenticatorSelection:{authenticatorAttachment:e.authenticatorSelection?.authenticatorAttachment||"platform",userVerification:e.authenticatorSelection?.userVerification||"required",residentKey:e.authenticatorSelection?.residentKey||r.residentKey},extensions:{prf:{eval:{first:(new TextEncoder).encode(e.encryptionSalt)}}}},o=await navigator.credentials.create({publicKey:n});if(!o)return{success:!1,error:"Failed to create credential - user may have cancelled"};const s={id:o.id,rawId:o.rawId,publicKey:btoa(String.fromCharCode(...new Uint8Array(o.rawId))),attestationObject:btoa(String.fromCharCode(...new Uint8Array(o.response.attestationObject)))},l=o.getClientExtensionResults().prf;let c,u;if(console.log("=== PRF Extension Analysis (Creation) ==="),console.log("PRF Result Object:",l),console.log("PRF Enabled:",l?.enabled),console.log("PRF Results Available:",!!l?.results),console.log("PRF First Result:",l?.results?.first?`${l.results.first.byteLength} bytes`:"none"),l&&l.enabled)if(l.results&&l.results.first)console.log("✅ Got PRF results directly from credential creation"),console.log("PRF Output Length:",l.results.first.byteLength,"bytes"),c=await t.importKeyMaterial(l.results.first),u="PRF";else{console.log("⚠️ PRF enabled but no results - attempting get() operation...");const i=await this.attemptPRFGet(o.rawId,e.encryptionSalt,r);i.success?(c=i.keyMaterial,u="PRF"):(console.log("❌ PRF get() operation failed, falling back to credential ID:",i.error),c=await t.importKeyMaterial(o.rawId),u="CredentialID")}else console.log("❌ PRF not supported - using credential ID for key derivation"),console.log("Falling back to Credential ID method"),console.log("Credential ID Length:",o.rawId.byteLength,"bytes"),c=await t.importKeyMaterial(o.rawId),u="CredentialID";return{success:!0,credential:s,keyMaterial:c,keyDerivationMethod:u,prfResult:l}}catch(e){return{success:!1,error:`WebAuthn credential creation failed: ${e instanceof Error?e.message:"Unknown error"}`}}}static async authenticate(e,r){try{if(!e.encryptionSalt||""===e.encryptionSalt.trim())return{success:!1,error:"encryptionSalt is required and cannot be empty"};const i=crypto.getRandomValues(new Uint8Array(32)),a={challenge:i,allowCredentials:[{type:"public-key",id:Uint8Array.from(atob(e.allowCredentials[0].id),e=>e.charCodeAt(0))}],timeout:e.timeout||r.timeout,userVerification:e.userVerification||"required",extensions:{prf:{eval:{first:(new TextEncoder).encode(e.encryptionSalt)}}}},n=await navigator.credentials.get({publicKey:a});if(!n)return{success:!1,error:"Authentication failed - user may have cancelled"};const o=n.response,s=n.id,l=btoa(String.fromCharCode(...new Uint8Array(o.signature))),c=btoa(String.fromCharCode(...new Uint8Array(o.authenticatorData))),u=n.getClientExtensionResults().prf;let d,y;return console.log("=== PRF Extension Analysis (Authentication) ==="),console.log("PRF Result Object:",u),console.log("PRF Enabled:",u?.enabled),console.log("PRF Results Available:",!!u?.results),console.log("PRF First Result:",u?.results?.first?`${u.results.first.byteLength} bytes`:"none"),u&&u.results&&u.results.first&&u.results.first.byteLength>0?(console.log("✅ PRF extension successful - using PRF key material"),console.log("PRF Output Length:",u.results.first.byteLength,"bytes"),d=await t.importKeyMaterial(u.results.first),y="PRF"):u&&u.enabled&&!u.results&&r.isSamsung?(console.log("⚠️ Samsung Pass PRF enabled but no results - this is expected behavior"),console.log("❌ PRF not available - falling back to credential ID derivation"),d=await t.importKeyMaterial(n.rawId),y="CredentialID"):(console.log("❌ PRF not available - falling back to credential ID derivation"),d=await t.importKeyMaterial(n.rawId),y="CredentialID"),{success:!0,credentialId:s,signature:l,authenticatorData:c,keyMaterial:d,keyDerivationMethod:y,prfResult:u}}catch(e){return{success:!1,error:`WebAuthn authentication failed: ${e instanceof Error?e.message:"Unknown error"}`}}}static async attemptPRFGet(e,r,i){try{const i={challenge:crypto.getRandomValues(new Uint8Array(32)),allowCredentials:[{type:"public-key",id:e}],userVerification:"required",extensions:{prf:{eval:{first:(new TextEncoder).encode(r)}}}},a=(await navigator.credentials.get({publicKey:i})).getClientExtensionResults().prf;if(console.log("=== PRF Extension Analysis (Get Operation) ==="),console.log("Get PRF Result:",a),console.log("Get PRF Results Available:",!!a?.results),a&&a.results&&a.results.first){console.log("✅ PRF results obtained from get() operation");return{success:!0,keyMaterial:await t.importKeyMaterial(a.results.first)}}return{success:!1,error:"PRF get() operation failed - no results"}}catch(e){return{success:!1,error:`PRF get() operation failed: ${e instanceof Error?e.message:"Unknown error"}`}}}}class i{static validateCreateOptions(e){if(!e.rp||"object"!=typeof e.rp)return{valid:!1,error:"rp object is required"};if(!e.rp.name||0===e.rp.name.trim().length)return{valid:!1,error:"rp.name is required and cannot be empty"};if(!e.user||"object"!=typeof e.user)return{valid:!1,error:"user object is required"};if(!e.user.id||0===e.user.id.trim().length)return{valid:!1,error:"user.id is required and cannot be empty"};if(!e.user.name||0===e.user.name.trim().length)return{valid:!1,error:"user.name is required and cannot be empty"};if(!e.user.displayName||0===e.user.displayName.trim().length)return{valid:!1,error:"user.displayName is required and cannot be empty"};if(!e.challenge||0===e.challenge.trim().length)return{valid:!1,error:"challenge is required and cannot be empty"};if(!Array.isArray(e.pubKeyCredParams)||0===e.pubKeyCredParams.length)return{valid:!1,error:"pubKeyCredParams array is required and cannot be empty"};if(!e.encryptionSalt||0===e.encryptionSalt.trim().length)return{valid:!1,error:"encryptionSalt is required and cannot be empty"};if(void 0!==e.rp.id){if("string"!=typeof e.rp.id||0===e.rp.id.trim().length)return{valid:!1,error:"rp.id must be a non-empty string if provided"};if(!/^[a-zA-Z0-9.-]+$/.test(e.rp.id))return{valid:!1,error:"rp.id must be a valid hostname format"}}if(void 0!==e.timeout&&("number"!=typeof e.timeout||e.timeout<=0||e.timeout>6e5))return{valid:!1,error:"timeout must be a positive number between 1 and 600000 (10 minutes)"};if(void 0!==e.authenticatorSelection){if(void 0!==e.authenticatorSelection.userVerification){if(!["required","preferred","discouraged"].includes(e.authenticatorSelection.userVerification))return{valid:!1,error:"authenticatorSelection.userVerification must be 'required', 'preferred', or 'discouraged'"}}if(void 0!==e.authenticatorSelection.authenticatorAttachment){if(!["platform","cross-platform"].includes(e.authenticatorSelection.authenticatorAttachment))return{valid:!1,error:"authenticatorSelection.authenticatorAttachment must be 'platform' or 'cross-platform'"}}if(void 0!==e.authenticatorSelection.residentKey){if(!["required","preferred","discouraged"].includes(e.authenticatorSelection.residentKey))return{valid:!1,error:"authenticatorSelection.residentKey must be 'required', 'preferred', or 'discouraged'"}}}return{valid:!0}}static validateAuthOptions(e){if(!e.challenge||0===e.challenge.trim().length)return{valid:!1,error:"challenge is required and cannot be empty"};if(!Array.isArray(e.allowCredentials)||0===e.allowCredentials.length)return{valid:!1,error:"allowCredentials array is required and cannot be empty"};for(const t of e.allowCredentials){if(!t.id||0===t.id.trim().length)return{valid:!1,error:"allowCredentials[].id is required and cannot be empty"};if("public-key"!==t.type)return{valid:!1,error:"allowCredentials[].type must be 'public-key'"};try{atob(t.id)}catch(e){return{valid:!1,error:"allowCredentials[].id must be a valid base64 string"}}}if(void 0!==e.timeout&&("number"!=typeof e.timeout||e.timeout<=0||e.timeout>6e5))return{valid:!1,error:"timeout must be a positive number between 1 and 600000 (10 minutes)"};if(void 0!==e.userVerification){if(!["required","preferred","discouraged"].includes(e.userVerification))return{valid:!1,error:"userVerification must be 'required', 'preferred', or 'discouraged'"}}return e.encryptionSalt&&0!==e.encryptionSalt.trim().length?{valid:!0}:{valid:!1,error:"encryptionSalt is required and cannot be empty"}}}class a{static async createCredential(t){try{const a=i.validateCreateOptions(t);if(!a.valid)return{success:!1,error:a.error,diagnostics:this.getBasicDiagnostics()};const n=await this.checkWebAuthnSupport();if(!n.supported)return{success:!1,error:n.error,diagnostics:this.getBasicDiagnostics()};const o=e.detectPlatform(),s=await r.createCredential(t,o);if(!s.success)return{success:!1,error:s.error,diagnostics:this.buildDiagnostics(o,null,s.keyDerivationMethod||"unknown")};return{success:!0,credentialId:s.credential.id,keyDerivationMethod:s.keyDerivationMethod,diagnostics:this.buildDiagnostics(o,s.prfResult||null,s.keyDerivationMethod)}}catch(e){return{success:!1,error:`Unexpected error: ${e instanceof Error?e.message:"Unknown error"}`,diagnostics:this.getBasicDiagnostics()}}}static async authenticate(a){try{const n=i.validateAuthOptions(a);if(!n.valid)return{success:!1,error:n.error,diagnostics:this.getBasicDiagnostics()};const o=await this.checkWebAuthnSupport();if(!o.supported)return{success:!1,error:o.error,diagnostics:this.getBasicDiagnostics()};const s=e.detectPlatform(),l=await r.authenticate(a,s);if(!l.success)return{success:!1,error:l.error,diagnostics:this.buildDiagnostics(s,null,l.keyDerivationMethod||"unknown")};const c={success:!0,credentialId:l.credentialId,keyDerivationMethod:l.keyDerivationMethod,diagnostics:this.buildDiagnostics(s,l.prfResult||null,l.keyDerivationMethod)};if(l.keyMaterial&&(c.derivedKey=await this.keyToBase64(l.keyMaterial)),a.userData&&l.keyMaterial){const e=await t.encryptData(a.userData,l.keyMaterial,a.encryptionSalt);e.success&&(c.encryptedUserData=e.encryptedData)}return c}catch(e){return{success:!1,error:`Unexpected error: ${e instanceof Error?e.message:"Unknown error"}`,diagnostics:this.getBasicDiagnostics()}}}static async checkWebAuthnSupport(){if(console.log("=== WebAuthn Diagnostic Information ==="),console.log("User Agent:",navigator.userAgent),console.log("Platform:",navigator.platform),console.log("WebAuthn Support:",!!window.PublicKeyCredential),console.log("isUserVerifyingPlatformAuthenticatorAvailable:",!!window.PublicKeyCredential?.isUserVerifyingPlatformAuthenticatorAvailable),window.PublicKeyCredential&&window.PublicKeyCredential.getClientCapabilities)try{const e=await window.PublicKeyCredential.getClientCapabilities();console.log("Client Capabilities:",e)}catch(e){console.log("getClientCapabilities not supported or failed:",e)}else console.log("getClientCapabilities not available");if(!window.PublicKeyCredential||!window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable)return{supported:!1,error:"WebAuthn is not supported on this device"};try{const e=await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();if(console.log("Platform authenticator available:",e),!e)return{supported:!1,error:"Platform authenticator (Windows Hello/TouchID/etc.) is not available"}}catch(e){return{supported:!1,error:"Failed to check platform authenticator availability"}}return{supported:!0}}static buildDiagnostics(e,t,r){return{userAgent:navigator.userAgent,platform:navigator.platform,prfSupported:t?.enabled||!1,prfResultsAvailable:!!t?.results?.first,authenticatorType:this.getAuthenticatorType(r,e,t),keyDerivationMethod:r,credentialIdLength:0}}static getBasicDiagnostics(){return{userAgent:navigator.userAgent,platform:navigator.platform,prfSupported:!1,prfResultsAvailable:!1,authenticatorType:"Unknown",keyDerivationMethod:"unknown",credentialIdLength:0}}static async keyToBase64(e){const t=await crypto.subtle.exportKey("raw",e);return btoa(String.fromCharCode(...new Uint8Array(t)))}static getAuthenticatorType(e,t,r){return"PRF"===e?t.isSamsung?"Samsung Pass (PRF-enabled)":t.isIOS?"Face ID/Touch ID (PRF-enabled)":t.isWindows?"Windows Hello (PRF-enabled)":"Platform Authenticator (PRF-enabled)":t.isSamsung&&r?.enabled?"Samsung Pass (PRF detection issue)":t.isSamsung?"Samsung Pass (PIN fallback)":t.isIOS?"Face ID/Touch ID (fallback mode)":t.isWindows?"Windows Hello (fallback mode)":"Platform Authenticator (credential ID fallback)"}}const n={createCredential:a.createCredential.bind(a),authenticate:a.authenticate.bind(a)};return"undefined"!=typeof window&&(window.SimpleWebAuthn=n),n}();
//# sourceMappingURL=simple-webauthn.min.js.map
